<!DOCTYPE html>
<html lang="yes">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive Canvas Layout (2-State)</title>
    <style>
        /* Basic Reset and Fullscreen Setup */
        body, html {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden; /* Prevent scrollbars from window itself */
            font-family: Arial, sans-serif;
            background-color: #D2B48C; /* Retro Tan Background */
        }

        /* Grid Container Setup */
        #grid-container {
            display: grid;
            width: 100%;
            height: 100%;
            gap: 8px; /* Gap between grid items */
            padding: 8px; /* Padding around the grid container */
            box-sizing: border-box;
        }

        /* Common Styles for Grid Items (Menu, Board, Bench Divs) */
        .grid-item {
            padding: 4px; /* Padding inside each grid item */
            box-sizing: border-box;
            overflow: hidden; /* Ensure canvas doesn't overflow padding */
            border-radius: 6px; /* Rounded corners for items */
            display: flex; /* To help center canvas or content if needed */
            flex-direction: column; /* Default for content stacking */
            justify-content: center; /* Center content vertically */
            align-items: center; /* Center content horizontally */
            background-color: #D2B48C; /* Retro Tan Background */
        }

        /* Specific Item Styling */
        #menu-item {
            display: flex;
            flex-direction: row; /* Arrange icons horizontally */
            justify-content: space-around; /* Space icons equally */
            align-items: center;
            padding: 0 15px; /* Add some horizontal padding for icons */
        }

        #menu-item img {
            height: 70%; /* Adjust icon size relative to menu height */
            width: auto;
            max-width: 23%; /* Ensure icons don't overflow */
        }

        #board-item, .bench-item {
            border: 8px solid #FFFFFF; /* Wide white border */
            border-radius: 20px; /* Wide radius for the border */
        }
        
        /* Canvas Styling */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.15); /* Slightly transparent white */
            border-radius: 3px; /* Slightly rounded corners for canvas */
        }

        /* Layout 1: Tall (Aspect Ratio < 1.0) - 5 full-width divs stacked vertically */
        .layout-tall {
            /* Menu (short), Board (squarish), Bench, Bench, Bench */
            grid-template-rows: 0.5fr 3fr 0.5fr 0.5fr 0.5fr; 
            grid-template-columns: 1fr;    /* Single column */
        }
        .layout-tall #menu-item    { grid-row: 1; grid-column: 1; }
        .layout-tall #board-item   { grid-row: 2; grid-column: 1; }
        .layout-tall #bench1-div   { grid-row: 3; grid-column: 1; }
        .layout-tall #bench2-div   { grid-row: 4; grid-column: 1; }
        .layout-tall #bench3-div   { grid-row: 5; grid-column: 1; }


        /* Layout 2: Wide (Aspect Ratio >= 1.0) - 5 full-height divs arranged horizontally */
        .layout-wide {
            /* Menu (narrow), Board (squarish), Bench, Bench, Bench */
            grid-template-columns: 0.3fr 3fr 0.5fr 0.51fr 0.5fr; 
            grid-template-rows: 1fr; /* Single row */
        }
        .layout-wide #menu-item    { grid-row: 1; grid-column: 1; }
        .layout-wide #board-item   { grid-row: 1; grid-column: 2; }
        .layout-wide #bench1-div   { grid-row: 1; grid-column: 3; }
        .layout-wide #bench2-div   { grid-row: 1; grid-column: 4; }
        .layout-wide #bench3-div   { grid-row: 1; grid-column: 5; }

        .layout-wide #menu-item {
            display: flex;
            flex-direction: column; /* Arrange icons horizontally */
            justify-content: space-around; /* Space icons equally */
            align-items: center;
            padding: 15px 0px; /* Add some vertical padding for icons */
        }

        .layout-wide #menu-item img {
            width: 90%; /* Adjust icon size relative to menu width */
            height: auto;
            max-height: 93%; /* Ensure icons don't overflow */
            max-width: 83%; /* Ensure icons don't overflow */
        }

    </style>
</head>
<body>

    <div id="grid-container">
        <div id="menu-item" class="grid-item" data-name="Menu Area">
            <img src="images/concede_icon.png" alt="Concede">
            <img src="images/new_game_icon.png" alt="New Game">
            <img src="images/rules_icon.png" alt="Rules">
            <img src="images/chat_icon.png" alt="Chat">
        </div>

        <div id="board-item" class="grid-item" data-name="Board Area">
            <canvas id="board-canvas"></canvas>
        </div>

        <div id="bench1-div" class="grid-item bench-item" data-name="Bench Item 1">
            <canvas id="bench1-canvas"></canvas>
        </div>
        <div id="bench2-div" class="grid-item bench-item" data-name="Bench Item 2">
            <canvas id="bench2-canvas"></canvas>
        </div>
        <div id="bench3-div" class="grid-item bench-item" data-name="Bench Item 3">
            <canvas id="bench3-canvas"></canvas>
        </div>
    </div>

    <script>
        /**
         * Sets the canvas drawing surface size to its displayed size (CSS pixels).
         * @param {HTMLCanvasElement} canvasElement The canvas element to size.
         */
        let benchOrientation = 'horizontal';

        function sizeCanvas(canvasElement) {
            if (!canvasElement) {
                console.error("sizeCanvas: Provided canvasElement is null or undefined.");
                return;
            }
            canvasElement.width = canvasElement.clientWidth;
            canvasElement.height = canvasElement.clientHeight;

            if (canvasElement.width === 0 || canvasElement.height === 0) {
                console.warn(`Canvas ${canvasElement.id || 'unnamed'} has zero dimension, skipping sizing.`);
                return;
            }
            const parentDiv = canvasElement.parentElement;
            const name = canvasElement.id || (parentDiv ? parentDiv.dataset.name : 'Unnamed Canvas');
            console.log(`Sized: ${name}, Dimensions: (${canvasElement.width.toFixed(2)}, ${canvasElement.height.toFixed(2)})`);
        }

        /**
         * Resizes all canvas elements in the document.
         */
        function resizeAllCanvases() {
            document.querySelectorAll('canvas').forEach(canvas => {
                if (canvas.offsetParent !== null && canvas.clientWidth > 0 && canvas.clientHeight > 0) {
                    sizeCanvas(canvas);
                    // Draw the board on the board canvas element
                    if (canvas.id === 'board-canvas') {
                        drawBoard(canvas, boardState);
                    }
                    if (canvas.id === 'bench1-canvas') {
                        drawBench(canvas, benchState,.9, benchOrientation);
                    }
                }
            });
        }

        /**
         * Updates the layout class on the grid container based on window aspect ratio
         * and then triggers a resize of all canvases.
         */
        function updateLayoutAndSize() {
            const container = document.getElementById('grid-container');
            if (!container) {
                console.error("Grid container not found.");
                return;
            }

            const aspectRatio = window.innerWidth / window.innerHeight;
            const threshold = 1.0; // If width < height (aspect < 1.0), it's "tall"

            container.classList.remove('layout-tall', 'layout-wide');

            let newLayoutClass = '';
            if (aspectRatio < threshold) { 
                newLayoutClass = 'layout-tall';
                benchOrientation = 'horizontal';
            } else { 
                newLayoutClass = 'layout-wide';
                benchOrientation = 'vertical';
            }
            container.classList.add(newLayoutClass);
            console.log(`Applied layout: ${newLayoutClass} (Aspect Ratio: ${aspectRatio.toFixed(2)})`);

            // Use requestAnimationFrame to ensure sizing happens after layout is applied
            requestAnimationFrame(resizeAllCanvases);
        }

        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded and parsed.");
            updateLayoutAndSize(); 
            window.addEventListener('resize', updateLayoutAndSize);
        });

        function hexagon(canvasElement, x, y, apothem, borderColor, fillColor, rotation = 0) {
            const ctx = canvasElement.getContext('2d');
            ctx.beginPath();

            const sideLength = (2 * apothem) / Math.sqrt(3);
            const radius = sideLength;

            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i - rotation;
                const vertexX = x + radius * Math.cos(angle);
                const vertexY = y + radius * Math.sin(angle);
                if (i === 0) {
                    ctx.moveTo(vertexX, vertexY);
                } else {
                    ctx.lineTo(vertexX, vertexY);
                }
            }

            ctx.closePath();
            ctx.fillStyle = fillColor;
            ctx.fill();
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = 4 * (apothem / 40); // Scale line width with apothem
            ctx.stroke();
        }

        const boardState = [
            "OO","OO","OO","P1",
            "OO","OO","OO","OO","OO",
            "OO","P2","SF","SF","OO","OO",
            "OO","OO","IM","CE","IM","OO","OO",
            "OO","OO","SF","SF","OO","OO",
            "OO","OO","IM","OO","OO",
            "OO","P3","P3","P3",
        ];

        const benchState = ["OO","OO","OO","P1","P1","P1","P1","P1"];

        function getColors(boardState, hexNumber) {
            switch(boardState[hexNumber]) {
                case 'P1':
                    return ['rgb(23, 114, 69)', 'rgb(15, 75, 45)']; // dark green with darker green border
                case 'P2':
                    return ['rgb(0, 0, 255)', 'rgb(0, 0, 200)']; // blue with darker blue border
                case 'P3':
                    return ['rgb(250, 250, 0)', 'rgb(150, 150, 100)']; // red with darker red border (note: comment says red, but color is yellow, I'll follow the color)
                case 'SF':
                    return ['rgb(100, 180, 255)', 'rgb(60, 140, 215)']; // sky blue with darker blue border
                case 'IM':
                    return ['rgb(25, 25, 25)', 'rgb(120, 120, 120)']; // yellow with darker yellow border (note: comment says yellow, but color is very dark, I'll follow the color)
                case 'CE':
                    return ['rgb(75, 200, 80)', 'rgb(40, 160, 45)']; // green with darker green border
                case 'OO':
                    return ['rgb(255, 255, 255)', 'rgb(100, 10, 100)']; // white with light gray border (note: comment says light gray, but color is purple, I'll follow the color)
                default:
                    return ['rgb(0, 0, 0)', 'rgb(50, 50, 50)']; // black with dark gray border
            }
        }

        function drawBoard(canvasElement, state, scale = 1.0) {
            const ctx = canvasElement.getContext('2d');
            ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            const canvasWidth = canvasElement.width;
            const canvasHeight = canvasElement.height;

            const rotation = Math.PI / 2;
            const rows = [4, 5, 6, 7, 6, 5, 4];

            // Calculate base dimensions for scaling
            // Assuming a base apothem of 40 (from original code)
            const baseApothem = 40;
            const baseSideLength = (2 * baseApothem) / Math.sqrt(3);
            const baseHexHorizontalSpacing = 2 * baseApothem;
            const baseHexVerticalStagger = baseSideLength * 1.5;

            // Calculate max theoretical width and height of the board layout
            const maxRowLength = Math.max(...rows);
            const theoreticalBoardWidth = (maxRowLength - 1) * baseHexHorizontalSpacing + (2 * baseApothem);
            const theoreticalBoardHeight = (rows.length - 1) * baseHexVerticalStagger + (2 * baseSideLength); // Height includes top and bottom hexagon

            // Calculate scaling factor to fit the board within the canvas
            const scaleFactorX = canvasWidth / theoreticalBoardWidth;
            const scaleFactorY = canvasHeight / theoreticalBoardHeight;

            // Use the smaller scale factor to ensure the entire board fits
            const boardScale = Math.min(scaleFactorX, scaleFactorY) * scale;

            // Apply the calculated scale to the apothem and spacing
            const apothem = baseApothem * boardScale;
            const sideLength = (2 * apothem) / Math.sqrt(3);
            const hexHorizontalSpacing = 2 * apothem;
            const hexVerticalStagger = sideLength * 1.5;

            // Calculate the actual total width and height of the scaled board
            const actualBoardWidth = (maxRowLength - 1) * hexHorizontalSpacing + (2 * apothem);
            const actualBoardHeight = (rows.length - 1) * hexVerticalStagger + (2 * sideLength);


            // Calculate initial X and Y to center the entire arrangement on the canvas
            const initialCenterX = canvasWidth / 2;
            const initialCenterY = canvasHeight / 2;

            // The starting Y position for the first row, accounting for centering
            let currentY = initialCenterY - (actualBoardHeight / 2) + apothem; // Add apothem to account for hexagon's top edge


            let hexNum = 0;
            for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
                const numHexagonsInRow = rows[rowIndex];

                // Calculate the start X for the current row to center it.
                const rowWidth = (numHexagonsInRow - 1) * hexHorizontalSpacing;
                let startX = initialCenterX - (rowWidth / 2);
                
                for (let i = 0; i < numHexagonsInRow; i++) {
                    const hexX = startX + i * hexHorizontalSpacing;
                    const hexY = currentY;

                    const [fillColor, borderColor] = getColors(state, hexNum);
                    
                    hexagon(canvasElement, hexX, hexY, apothem * .9, borderColor, fillColor, rotation);
                    hexNum++;
                }
                currentY += hexVerticalStagger;
            }
        }

        function drawBench(canvasElement, state, scale, orientation = 'horizontal') {
            const ctx = canvasElement.getContext('2d');
            ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            const canvasWidth = canvasElement.width;
            const canvasHeight = canvasElement.height;

            let baseApothem;

            // Determine baseApothem based on orientation and canvas dimension
            if (orientation === 'horizontal') {
                baseApothem = canvasHeight / 4; // Scales apothem based on canvas height for horizontal
            } else if (orientation === 'vertical') {
                baseApothem = canvasWidth / 1.7; // Scales apothem based on canvas width for vertical
            } else {
                console.error("Invalid orientation specified for drawBench. Use 'horizontal' or 'vertical'.");
                return; // Exit if orientation is invalid
            }

            const apothem = Math.min(baseApothem * scale, 20); // Apply scale and cap at 20
            const rotation = Math.PI / 2; // Hexagons rotated by 90 degrees
            const sideLength = (2 * apothem) / Math.sqrt(3);

            const hexHorizontalSpacing = 2.5 * apothem; // Distance between centers for horizontal arrangement
            const hexVerticalSpacing = sideLength * 2.5; // Distance between centers for vertical arrangement

            const numHexagons = state.length; // Should be 8 for the bench

            let startX, startY;

            if (orientation === 'horizontal') {
                const totalWidth = (numHexagons - 1) * hexHorizontalSpacing + (2 * apothem);
                startX = (canvasWidth / 2) - (totalWidth / 2) + apothem; // Center horizontally
                startY = canvasHeight / 2; // Center vertically
                
                for (let i = 0; i < numHexagons; i++) {
                    const hexX = startX + i * hexHorizontalSpacing;
                    const hexY = startY;
                    const [fillColor, borderColor] = getColors(state, i);
                    hexagon(canvasElement, hexX, hexY, apothem * .9, borderColor, fillColor, rotation);
                }
            } else if (orientation === 'vertical') {
                const totalHeight = (numHexagons - 1) * hexVerticalSpacing + (2 * sideLength);
                startX = canvasWidth / 2; // Center horizontally
                startY = (canvasHeight / 2) - (totalHeight / 2) + sideLength; // Center vertically
                
                for (let i = 0; i < numHexagons; i++) {
                    const hexX = startX;
                    const hexY = startY + i * hexVerticalSpacing;
                    const [fillColor, borderColor] = getColors(state, i);
                    hexagon(canvasElement, hexX, hexY, apothem * .9, borderColor, fillColor, rotation);
                }
            }
        }
    </script>

</body>
</html>
